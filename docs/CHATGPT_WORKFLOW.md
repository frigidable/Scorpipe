# CHATGPT_WORKFLOW — Scorpipe

Этот документ фиксирует “стабильный протокол” работы над репозиторием через ChatGPT:
минимум потерь, максимум скорости, предсказуемые релизы.

---

## 0) Коротко: ваш идеальный цикл

1) Вы формулируете задачу по шаблону ниже и прикрепляете **zip актуального репозитория**.
2) ChatGPT отвечает **Commit Pack 1..N** (несколько логических изменений).
3) Вы последовательно применяете пакеты (замена файлов), делаете коммиты в GitHub Desktop.
4) Создаёте PR с **Conventional** заголовком → CI зелёный → **Squash & Merge**.
5) Release Please сам откроет Release PR, а после его merge релиз опубликуется и `windows_release.yml` приклеит артефакты.

---

## 1) Шаблон задачи (вставляйте вместе с zip)

**Контекст**
- Версия архива: `vX.Y.Z`
- Что сломано/чего не хватает: (1–3 предложения)

**Цель**
- (1 предложение)

**DoD (Definition of Done)**
- [ ] …
- [ ] …
- [ ] …

**Ограничения**
- Нельзя/нужно: (например “не менять публичные пути outputs”, “не добавлять зависимости”)

**Файлы/папки**
- Где править: `...`
- Где смотреть тесты: `tests/...`

**Проверка**
- GitHub Actions должны быть зелёные: `CI`, `Windows Release` (если применимо)
- Что вручную проверить: (если нужно)

---

## 2) Что мы просим у ChatGPT в ответе

По умолчанию: **Commit Pack 1..N**, каждый пакет содержит:
- commit message (Conventional),
- список изменённых файлов,
- что изменено (кратко),
- DoD для пакета.

Важно: если есть `DELETE`/`RENAME` — это отдельным явным пунктом.

---

## 3) Как вы применяете ответ (без терминала)

Для каждого Commit Pack:
1) Обновляете файлы в локальном репо (заменой/распаковкой).
2) В GitHub Desktop проверяете вкладку **Changes**:
   - набор файлов совпадает со списком из пакета,
   - нет “лишних” изменений.
3) Коммитите с указанным commit message.
4) Переходите к следующему пакету.

Затем:
- Push ветки,
- PR title = Conventional (CI проверит автоматически),
- Squash & Merge.

---

## 4) Как быстро помогать ChatGPT диагностировать падения CI

Если CI упал — прикладывайте:
- ссылку на job в Actions и/или полный лог ошибки,
- `pytest` traceback,
- если это Windows build: текст ошибки ISCC / PyInstaller / path mismatch.

Чем точнее вход, тем меньше итераций.
